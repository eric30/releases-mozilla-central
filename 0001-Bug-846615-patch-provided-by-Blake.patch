From bf919390f83515c3d315d877c81d5f395e2bb979 Mon Sep 17 00:00:00 2001
From: Eric Chou <echou@mozilla.com>
Date: Thu, 7 Mar 2013 12:24:30 +0800
Subject: [PATCH] Bug-846615-patch-provided-by-Blake

---
 ipc/unixsocket/UnixSocket.cpp |  350 +++++++++++++++++++----------------------
 ipc/unixsocket/UnixSocket.h   |    5 -
 2 files changed, 159 insertions(+), 196 deletions(-)

diff --git a/ipc/unixsocket/UnixSocket.cpp b/ipc/unixsocket/UnixSocket.cpp
index f641bfe..46966e5 100644
--- a/ipc/unixsocket/UnixSocket.cpp
+++ b/ipc/unixsocket/UnixSocket.cpp
@@ -47,20 +47,17 @@ public:
                  const nsACString& aAddress)
     : mConsumer(aConsumer)
     , mIOLoop(nullptr)
-    , mFd(-1)
     , mConnector(aConnector)
-    , mCurrentTaskIsCanceled(false)
+    , mShuttingDownOnIOThread(false)
     , mTask(nullptr)
     , mAddress(aAddress)
-    , mLock("UnixSocketImpl.mLock")
   {
   }
 
   ~UnixSocketImpl()
   {
-    StopTask();
-    mReadWatcher.StopWatchingFileDescriptor();
-    mWriteWatcher.StopWatchingFileDescriptor();
+    MOZ_ASSERT(NS_IsMainThread());
+    MOZ_ASSERT(IsShutdownOnMainThread());
   }
 
   void QueueWriteData(UnixSocketRawData* aData)
@@ -74,25 +71,46 @@ public:
     return mFd > 0;
   }
 
-  void CancelTask()
+  bool IsShutdownOnMainThread()
   {
-    MutexAutoLock lock(mLock);
-    mCurrentTaskIsCanceled = true;
+    MOZ_ASSERT(NS_IsMainThread());
+    return mConsumer == nullptr;
   }
   
-  bool IsCanceled()
+  void ShutdownOnMainThread()
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+    MOZ_ASSERT(!IsShutdownOnMainThread());
+    mConsumer == nullptr;
+  }
+
+  bool IsShutdownOnIOThread()
   {
-    MutexAutoLock lock(mLock);
-    return mCurrentTaskIsCanceled;
+    return mShuttingDownOnIOThread;
   }
 
-  void UnsetTask()
+  void ShutdownOnIOThread()
   {
-    mTask = nullptr;
+    MOZ_ASSERT(!NS_IsMainThread());
+    MOZ_ASSERT(!mShuttingdownOnIOThread);
+
+    mReadWatcher.StopWatchingFileDescriptor();
+    mWriteWatcher.StopWatchingFileDescriptor();
+
+    mShuttingDownOnIOThread = true;
+    if (mTask) {
+      mTask->Cancel();
+      mTask = nullptr;
+    }
   }
 
+  // NB: Any CancelableTask that is passed into EnqueueTask *must* set mTask to
+  // nullptr in its run method if it was not already canceled.
   void EnqueueTask(int aDelayMs, CancelableTask* aTask)
   {
+    MOZ_ASSERT(!NS_IsMainThread());
+
+    nsAutoPtr<CancelableTask> task(aTask);
     MessageLoopForIO* ioLoop = MessageLoopForIO::current();
     if (!ioLoop) {
       NS_WARNING("No IOLoop to attach to, cancelling self!");
@@ -101,17 +119,18 @@ public:
     if (mTask) {
       return;
     }
-    if (IsCanceled()) {
+    if (mShuttingDownOnIOThread) {
       return;
     }
-    mTask = aTask;
+
+    mTask = task.forget();
     if (aDelayMs) {
       ioLoop->PostDelayedTask(FROM_HERE, mTask, aDelayMs);
     } else {
       ioLoop->PostTask(FROM_HERE, mTask);
     }
   }
-  
+
   void SetUpIO()
   {
     MOZ_ASSERT(!mIOLoop);
@@ -139,25 +158,7 @@ public:
    */
   void Accept();
 
-  /** 
-   * Close an open connection
-   */
-  void Close();
-
   /**
-   * Stop whatever connect/accept task is running
-   */
-  void StopTask()
-  {
-    if (mTask) {
-      mTask->Cancel();
-      mTask = nullptr;
-    }
-    MutexAutoLock lock(mLock);
-    mCurrentTaskIsCanceled = true;
-  }
-
-  /** 
    * Set up nonblocking flags on whatever our current file descriptor is.
    *
    * @return true if successful, false otherwise
@@ -169,7 +170,7 @@ public:
     if (!mConnector)
     {
       NS_WARNING("No connector to get socket address from!");
-      aAddrStr = nsString();
+      aAddrStr.Truncate();
       return;
     }
     mConnector->GetSocketAddr(mAddr, aAddrStr);
@@ -211,11 +212,6 @@ private:
   UnixSocketRawDataQueue mOutgoingQ;
 
   /**
-   * Incoming packet. Only to be accessed on IO Thread.
-   */
-  nsAutoPtr<UnixSocketRawData> mIncoming;
-
-  /**
    * Read watcher for libevent. Only to be accessed on IO Thread.
    */
   MessageLoopForIO::FileDescriptorWatcher mReadWatcher;
@@ -239,7 +235,7 @@ private:
   /**
    * If true, do not requeue whatever task we're running
    */
-  bool mCurrentTaskIsCanceled;
+  bool mShuttingDownOnIOThread;
 
   /**
    * Pointer to the task we're currently running. DO NOT DELETE MANUALLY. This
@@ -261,11 +257,6 @@ private:
    * Address struct of the socket currently in use
    */
   sockaddr mAddr;
-
-  /**
-   * Protects mCurrentTaskIsCanceled
-   */
-  mozilla::Mutex mLock;
 };
 
 template<class T>
@@ -301,13 +292,14 @@ public:
     mEvent(e)
   {
     MOZ_ASSERT(aImpl);
+    MOZ_ASSERT(!NS_IsMainThread());
   }
 
   NS_IMETHOD Run()
   {
     MOZ_ASSERT(NS_IsMainThread());
-    if (!mImpl->mConsumer) {
-      NS_WARNING("CloseSocket has already been called! (mConsumer is null)");
+    if (mImpl->IsShutdownOnMainThread()) {
+      NS_WARNING("CloseSocket has already been called!");
       // Since we've already explicitly closed and the close happened before
       // this, this isn't really an error. Since we've warned, return OK.
       return NS_OK;
@@ -339,12 +331,15 @@ public:
 
   NS_IMETHOD Run()
   {
-    if(!mImpl->mConsumer) {
+    MOZ_ASSERT(NS_IsMainThread());
+    if(mImpl->IsShutdownOnMainThread()) {
       NS_WARNING("mConsumer is null, aborting receive!");
       // Since we've already explicitly closed and the close happened before
       // this, this isn't really an error. Since we've warned, return OK.
       return NS_OK;
     }
+
+    MOZ_ASSERT(mImpl->mConsumer);
     mImpl->mConsumer->ReceiveSocketData(mRawData);
     return NS_OK;
   }
@@ -370,6 +365,9 @@ public:
   void
   Run()
   {
+    MOZ_ASSERT(!NS_IsMainThread());
+    MOZ_ASSERT(!mImpl->IsShutdownOnIOThread());
+
     mImpl->QueueWriteData(mData);
   }
 
@@ -379,44 +377,6 @@ private:
   UnixSocketRawData* mData;
 };
 
-class SocketCloseTask : public Task
-{
-public:
-  SocketCloseTask(UnixSocketImpl* aImpl)
-    : mImpl(aImpl)
-  {
-    MOZ_ASSERT(aImpl);
-  }
-
-  void Run()
-  {
-    NS_ENSURE_TRUE_VOID(mImpl);
-
-    mImpl->UnsetTask();
-    mImpl->Close();
-  }
-
-private:
-  UnixSocketImpl* mImpl;
-};
-
-class StartImplReadingTask : public Task
-{
-public:
-  StartImplReadingTask(UnixSocketImpl* aImpl)
-    : mImpl(aImpl)
-  {
-  }
-
-  void
-  Run()
-  {
-    mImpl->SetUpIO();
-  }
-private:
-  UnixSocketImpl* mImpl;
-};
-
 class RequestClosingSocketTask : public nsRunnable
 {
 public:
@@ -429,14 +389,15 @@ public:
   {
     MOZ_ASSERT(NS_IsMainThread());
 
-    if(!mImpl->mConsumer) {
-      NS_WARNING("CloseSocket has already been called! (mConsumer is null)");
+    if (mImpl->IsShutdownOnMainThread()) {
+      NS_WARNING("CloseSocket has already been called!");
       // Since we've already explicitly closed and the close happened before
       // this, this isn't really an error. Since we've warned, return OK.
       return NS_OK;
     }
 
-    // Start from here, same handling flow as calling CloseSocket() from upper layer
+    // Start from here, same handling flow as calling CloseSocket() from
+    // upper layer
     mImpl->mConsumer->CloseSocket();
     return NS_OK;
   }
@@ -447,54 +408,70 @@ private:
 class SocketAcceptTask : public CancelableTask {
   virtual void Run();
 
-  bool mCanceled;
   UnixSocketImpl* mImpl;
 public:
-  virtual void Cancel() { mCanceled = true; }
-  SocketAcceptTask(UnixSocketImpl* aImpl) : mCanceled(false), mImpl(aImpl) { }
+  SocketAcceptTask(UnixSocketImpl* aImpl) : mImpl(aImpl) { }
+
+  virtual void Cancel()
+  {
+    MOZ_ASSERT(!NS_IsMainThread());
+    mImpl = nullptr;
+  }
 };
 
-void SocketAcceptTask::Run() {
-  mImpl->UnsetTask();
-  if (mCanceled) {
-    return;
+void SocketAcceptTask::Run()
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+
+  if (mImpl) {
+    mImpl->Accept();
   }
-  mImpl->Accept();
 }
 
-class SocketConnectTask : public CancelableTask {
+class SocketConnectTask : public Task {
   virtual void Run();
 
-  bool mCanceled;
   UnixSocketImpl* mImpl;
 public:
-  SocketConnectTask(UnixSocketImpl* aImpl) : mCanceled(false), mImpl(aImpl) { }
-  virtual void Cancel() { mCanceled = true; }  
+  SocketConnectTask(UnixSocketImpl* aImpl) : mImpl(aImpl) { }
 };
 
-void SocketConnectTask::Run() {
-  mImpl->UnsetTask();
-  if (mCanceled) {
-    return;
-  }
+void SocketConnectTask::Run()
+{
+  MOZ_ASSERT(!NS_IsMainThread());
   mImpl->Connect();
 }
 
-void
-UnixSocketImpl::Close()
+class ShutdownSocketTask : public Task {
+  virtual void Run();
+
+  UnixSocketImpl* mImpl;
+
+public:
+  ShutdownSocketTask(UnixSocketImpl* aImpl) : mImpl(aImpl) { }
+};
+
+void ShutdownSocketTask::Run()
 {
-  mReadWatcher.StopWatchingFileDescriptor();
-  mWriteWatcher.StopWatchingFileDescriptor();
+  MOZ_ASSERT(!NS_IsMainThread());
 
-  nsRefPtr<nsIRunnable> t(new DeleteInstanceRunnable<UnixSocketImpl>(this));
-  NS_ENSURE_TRUE_VOID(t);
+  // At this point, there should be no new events on the IO thread after this
+  // one with the possible exception of a SocketAcceptTask that
+  // ShutdownOnIOThread will cancel for us. We are now fully shut down, so we
+  // can send a message to the main thread that will delete mImpl safely knowing
+  // that no more tasks reference it.
+  mImpl->ShutdownOnIOThread();
+
+  nsRefPtr<nsIRunnable> t(new DeleteInstanceRunnable<UnixSocketImpl>(mImpl));
   nsresult rv = NS_DispatchToMainThread(t);
   NS_ENSURE_SUCCESS_VOID(rv);
 }
 
-void
+void  
 UnixSocketImpl::Accept()
 {
+  MOZ_ASSERT(!NS_IsMainThread());
+  mTask = nullptr;
 
   if (!mConnector) {
     NS_WARNING("No connector object available!");
@@ -538,6 +515,13 @@ UnixSocketImpl::Accept()
 void
 UnixSocketImpl::Connect()
 {
+  MOZ_ASSERT(!NS_IsMainThread());
+
+  if (!mConnector) {
+    NS_WARNING("No connector object available!");
+    return;
+  }
+
   if(mFd.get() < 0)
   {
     mFd = mConnector->Create();
@@ -572,11 +556,7 @@ UnixSocketImpl::Connect()
     new OnSocketEventTask(this, OnSocketEventTask::CONNECT_SUCCESS);
   NS_DispatchToMainThread(t);
 
-  // Due to the fact that we've dispatched our OnConnectSuccess message before
-  // starting reading, we're guaranteed that any subsequent read tasks will
-  // happen after the object has been notified of a successful connect.
-  XRE_GetIOMessageLoop()->PostTask(FROM_HERE,
-                                   new StartImplReadingTask(this));
+  SetUpIO();
 }
 
 bool
@@ -616,6 +596,8 @@ UnixSocketConsumer::SendSocketData(UnixSocketRawData* aData)
   if (!mImpl) {
     return false;
   }
+
+  MOZ_ASSERT(!mImpl->IsShutdownOnMainThread());
   XRE_GetIOMessageLoop()->PostTask(FROM_HERE,
                                    new SocketSendTask(this, mImpl, aData));
   return true;
@@ -631,9 +613,10 @@ UnixSocketConsumer::SendSocketData(const nsACString& aStr)
   if (aStr.Length() > MAX_READ_SIZE) {
     return false;
   }
-  nsCString str(aStr);
+
+  MOZ_ASSERT(!mImpl->IsShutdownOnMainThread());
   UnixSocketRawData* d = new UnixSocketRawData(aStr.Length());
-  memcpy(d->mData, str.get(), aStr.Length());
+  memcpy(d->mData, aStr.BeginReading(), aStr.Length());
   XRE_GetIOMessageLoop()->PostTask(FROM_HERE,
                                    new SocketSendTask(this, mImpl, d));
   return true;
@@ -642,19 +625,20 @@ UnixSocketConsumer::SendSocketData(const nsACString& aStr)
 void
 UnixSocketConsumer::CloseSocket()
 {
-  // Needed due to refcount change
   MOZ_ASSERT(NS_IsMainThread());
   if (!mImpl) {
     return;
   }
-  UnixSocketImpl* impl = mImpl;
-  // To make sure the owner doesn't die on the IOThread, remove pointer here
-  mImpl = nullptr;
-  // Line it up to be destructed on the IO Thread
-  impl->mConsumer.forget();
-  impl->CancelTask();
 
-  XRE_GetIOMessageLoop()->PostTask(FROM_HERE, new SocketCloseTask(impl));
+  // From this point on, we consider mImpl as being deleted.
+  // We sever the relationship here so any future calls to listen or connect
+  // will create a new implementation.
+  mImpl->ShutdownOnMainThread();
+
+  XRE_GetIOMessageLoop()->PostTask(FROM_HERE,
+                                   new ShutdownSocketTask(mImpl));
+
+  mImpl = nullptr;
 
   NotifyDisconnect();
 }
@@ -662,57 +646,55 @@ UnixSocketConsumer::CloseSocket()
 void
 UnixSocketImpl::OnFileCanReadWithoutBlocking(int aFd)
 {
-  enum SocketConnectionStatus status = mConsumer->GetConnectionStatus();
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(!mShuttingDownOnIOThread);
 
+  SocketConnectionStatus status = mConsumer->GetConnectionStatus();
   if (status == SOCKET_CONNECTED) {
-
-    // Keep reading data until either
-    //
-    //   - mIncoming is completely read
-    //     If so, sConsumer->MessageReceived(mIncoming.forget())
-    //
-    //   - mIncoming isn't completely read, but there's no more
-    //     data available on the socket
-    //     If so, break;
+    // Read all of the incoming data.
     while (true) {
-      if (!mIncoming) {
-        uint8_t data[MAX_READ_SIZE];
-        ssize_t ret = read(aFd, data, MAX_READ_SIZE);
-        if (ret < 0) {
-          if (ret == -1) {
-            if (errno == EINTR) {
-              continue; // retry system call when interrupted
-            }
-            else if (errno == EAGAIN || errno == EWOULDBLOCK) {
-              return; // no data available: return and re-poll
-            }
-            // else fall through to error handling on other errno's
+      uint8_t data[MAX_READ_SIZE];
+      ssize_t ret = read(aFd, data, MAX_READ_SIZE);
+      if (ret <= 0) {
+        if (ret == -1) {
+          if (errno == EINTR) {
+            continue; // retry system call when interrupted
+          }
+          if (errno == EAGAIN || errno == EWOULDBLOCK) {
+            return; // no data available: return and re-poll
           }
+
 #ifdef DEBUG
           NS_WARNING("Cannot read from network");
 #endif
-          // At this point, assume that we can't actually access
-          // the socket anymore
-          mReadWatcher.StopWatchingFileDescriptor();
-          mWriteWatcher.StopWatchingFileDescriptor();
-          nsRefPtr<RequestClosingSocketTask> t = new RequestClosingSocketTask(this);
-          NS_DispatchToMainThread(t);
-          return;
-        }
-        if (ret) {
-          mIncoming = new UnixSocketRawData(ret);
-          memcpy(mIncoming->mData, data, ret);
-          nsRefPtr<SocketReceiveTask> t =
-            new SocketReceiveTask(this, mIncoming.forget());
-          NS_DispatchToMainThread(t);
-        }
-        if (ret < ssize_t(MAX_READ_SIZE)) {
-          return;
+          // else fall through to error handling on other errno's
         }
+
+        // We're done with our descriptors. Ensure that spurious events don't
+        // cause us to end up back here.
+        mReadWatcher.StopWatchingFileDescriptor();
+        mWriteWatcher.StopWatchingFileDescriptor();
+        nsRefPtr<RequestClosingSocketTask> t = new RequestClosingSocketTask(this);
+        NS_DispatchToMainThread(t);
+        return;
+      }
+
+      UnixSocketRawData* incoming = new UnixSocketRawData(ret);
+      memcpy(incoming->mData, data, ret);
+      nsRefPtr<SocketReceiveTask> t = new SocketReceiveTask(this, incoming);
+      NS_DispatchToMainThread(t);
+
+      // If ret is less than MAX_READ_SIZE, there's no more data in the socket
+      // for us to read now.
+      if (ret < ssize_t(MAX_READ_SIZE)) {
+        return;
       }
     }
-  } else if (status == SOCKET_LISTENING) {
 
+    MOZ_NOT_REACHED("We returned early");
+  }
+
+  if (status == SOCKET_LISTENING) {
     int client_fd = accept(mFd.get(), &mAddr, &mAddrSize);
 
     if (client_fd < 0) {
@@ -734,17 +716,16 @@ UnixSocketImpl::OnFileCanReadWithoutBlocking(int aFd)
       new OnSocketEventTask(this, OnSocketEventTask::CONNECT_SUCCESS);
     NS_DispatchToMainThread(t);
 
-    // Due to the fact that we've dispatched our OnConnectSuccess message before
-    // starting reading, we're guaranteed that any subsequent read tasks will
-    // happen after the object has been notified of a successful connect.
-    XRE_GetIOMessageLoop()->PostTask(FROM_HERE,
-                                     new StartImplReadingTask(this));
+    SetUpIO();
   }
 }
 
 void
 UnixSocketImpl::OnFileCanWriteWithoutBlocking(int aFd)
 {
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(!mShuttingDownOnIOThread);
+
   // Try to write the bytes of mCurrentRilRawData.  If all were written, continue.
   //
   // Otherwise, save the byte position of the next byte to write
@@ -791,9 +772,9 @@ UnixSocketImpl::OnFileCanWriteWithoutBlocking(int aFd)
 void
 UnixSocketConsumer::GetSocketAddr(nsAString& aAddrStr)
 {
+  aAddrStr.Truncate();
   if (!mImpl || mConnectionStatus != SOCKET_CONNECTED) {
     NS_WARNING("No socket currently open!");
-    aAddrStr = nsString();
     return;
   }
   mImpl->GetSocketAddr(aAddrStr);
@@ -834,8 +815,7 @@ UnixSocketConsumer::ConnectSocket(UnixSocketConnector* aConnector,
     NS_WARNING("Socket already connecting/connected!");
     return false;
   }
-  nsCString addr;
-  addr.Assign(aAddress);
+  nsCString addr(aAddress);
   mImpl = new UnixSocketImpl(this, aConnector, addr);
   MessageLoop* ioLoop = XRE_GetIOMessageLoop();
   mConnectionStatus = SOCKET_CONNECTING;
@@ -856,24 +836,12 @@ UnixSocketConsumer::ListenSocket(UnixSocketConnector* aConnector)
     NS_WARNING("Socket already connecting/connected!");
     return false;
   }
-  nsCString addr;
-  mImpl = new UnixSocketImpl(this, aConnector, addr);
+  mImpl = new UnixSocketImpl(this, aConnector, EmptyCString());
   mConnectionStatus = SOCKET_LISTENING;
   XRE_GetIOMessageLoop()->PostTask(FROM_HERE,
                                    new SocketAcceptTask(mImpl));
   return true;
 }
 
-void
-UnixSocketConsumer::CancelSocketTask()
-{
-  mConnectionStatus = SOCKET_DISCONNECTED;
-  if(!mImpl) {
-    NS_WARNING("No socket implementation to cancel task on!");
-    return;
-  }
-  mImpl->StopTask();
-}
-
 } // namespace ipc
 } // namespace mozilla
diff --git a/ipc/unixsocket/UnixSocket.h b/ipc/unixsocket/UnixSocket.h
index aef0251..6fecbae 100644
--- a/ipc/unixsocket/UnixSocket.h
+++ b/ipc/unixsocket/UnixSocket.h
@@ -184,11 +184,6 @@ public:
   void CloseSocket();
 
   /** 
-   * Cancels connect/accept task loop, if one is currently running.
-   */
-  void CancelSocketTask();
-
-  /** 
    * Callback for socket connect/accept success. Called after connect/accept has
    * finished. Will be run on main thread, before any reads take place.
    */
-- 
1.7.10.4

